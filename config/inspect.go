package config

import (
	"fmt"
	"sort"
	"sync"

	"github.com/fatih/color"
)

// AddConsul to the topology
func AddConsul(root *Root) error {
	// looking for resources
	var DC Datacenter
	var consul Root

	if root.Datacenters == nil && len(root.Datacenters) < 1 {
		// creating a default dc
		color.Yellow("File without dc creating one for default")
		DC.Name = "privateDC"
		DC.Description = "autogenerated DC"
		DC.Default = true
		consul.Datacenters = []*Datacenter{&DC}
	}

	if root.Datacenters != nil && len(root.Datacenters) > 0 {
		consul.Datacenters = root.Datacenters
		// If only one that's the default
		for i, dc := range root.Datacenters {
			if dc != nil && dc.Default {
				color.Green(
					"Using a dc from list with number: ", i)
				DC = *(root.Datacenters[i])
				break
			}
		}

		// No default just pick one
		if DC.Name == "" {
			color.Yellow(
				"-> No default dc found, selecting one")
			DC = *(root.Datacenters[0])
		}

	}

	// looking for the default DC
	color.Green("Using DC %+v", DC)

	/* what we need to know
	- By default we have the cluster per region
	- The load balancers will help for the intention which are connected with whom
	  in the pool and the flow egress/ingress/contains
	- the services list will tell you the size max will calculate the clients
	*/
	createConsulClients(root, &consul)

	return nil
}

//clientSize
func createConsulClients(src *Root, dest *Root) {
	// counting to remove dups associations

	serviceCount := make(map[string]metadata)
	for _, r := range src.Resources {
		// Service Pool size
		if r != nil && r.Type == ServicePool.String() {
			serviceCount[r.Name] = metadata{
				InstancesIDs: make(map[string]X),
				Location:     r.Location,
			}

			// contains
			if len(r.Associations) == 0 {
				continue
			}

			for _, assoc := range r.Associations {
				if assoc.Type == Contains.String() {
					serviceCount[r.Name].InstancesIDs[assoc.ID] = X{}
				}
			}
		}
	}

	// nothing to do
	if len(serviceCount) == 0 {
		color.Yellow("No services in the spec no consul clients required")
		return
	}

	// sort by order everything we got
	serviceOrder := make([]metadata, 0, len(serviceCount))

	for k, v := range serviceCount {
		v.Name = k
		serviceOrder = append(serviceOrder, v)
		fmt.Println(v)
	}

	sort.Stable(sortableMetadata(serviceOrder))

	// now sorting internals
	for i, serv := range serviceOrder {
		serv.CreateIndex()
		serviceOrder[i] = serv
	}

	//required elements
	clientNumber := len(serviceOrder[len(serviceOrder)-1].InstancesIDs)

	for _, r := range serviceOrder {
		fmt.Printf("%+v\n", r)
	}

	if clientNumber <= 0 {
		color.Yellow("No consul clients required after order because there are no instances in the service")
	}

	//consulClients := make([]*Resource, 0, clientNumber)
	color.Green("Required min clients %d", clientNumber)
	consulClients := make([]*Resource, 0, clientNumber)

	var wg sync.WaitGroup

	for i := 0; i < clientNumber; i++ {
		wg.Add(1)
		r := Resource{
			Type:         ConsulClient.String(),
			Name:         fmt.Sprintf("client-%d", i),
			Associations: make([]Association, 0, 0),
		}
		consulClients = append(consulClients, &r)

		go func(res *Resource, id int) {
			defer wg.Done()
			for _, serv := range serviceOrder {
				//color.Yellow("worker id %d , service %s", id, serv.Name)
				// no instances
				if len(serv.IndexIDs) == 0 {
					fmt.Println("nothing ... for us", id, serv.Name)
					continue
				}
				if id <= len(serv.IndexIDs)-1 {

					fmt.Println("-<", id, serv.Name)
					res.Associations = append(res.Associations, Association{
						ID:   serv.IndexIDs[id],
						Type: Contains.String(),
					})
				}
			}

		}(&r, i)
	}

	wg.Wait()

	for _, k := range consulClients {
		color.Green("%+v", *k)
	}
	// populating the clients

}
